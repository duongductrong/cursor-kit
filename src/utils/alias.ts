import {
  appendFileSync,
  chmodSync,
  existsSync,
  mkdirSync,
  readFileSync,
  unlinkSync,
  writeFileSync,
} from "node:fs";
import { homedir } from "node:os";
import { join } from "node:path";

export type AliasStorageLocation =
  | "shell-config"
  | "usr-local-bin"
  | "home-bin";

export interface AliasConfig {
  aliases: Record<string, AliasEntry>;
}

export interface AliasEntry {
  instanceName: string;
  aliasName: string;
  storageLocation: AliasStorageLocation;
  createdAt: string;
  scriptPath?: string;
}

const CURSOR_KIT_DIR = ".cursor-kit";
const ALIASES_FILE = "aliases.json";

export function getAliasConfigDir(): string {
  return join(homedir(), CURSOR_KIT_DIR);
}

export function getAliasConfigPath(): string {
  return join(getAliasConfigDir(), ALIASES_FILE);
}

export function ensureConfigDir(): void {
  const configDir = getAliasConfigDir();
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }
}

export function loadAliasConfig(): AliasConfig {
  const configPath = getAliasConfigPath();
  if (!existsSync(configPath)) {
    return { aliases: {} };
  }

  try {
    const content = readFileSync(configPath, "utf-8");
    return JSON.parse(content) as AliasConfig;
  } catch {
    return { aliases: {} };
  }
}

export function saveAliasConfig(config: AliasConfig): void {
  ensureConfigDir();
  const configPath = getAliasConfigPath();
  writeFileSync(configPath, JSON.stringify(config, null, 2), "utf-8");
}

export function getInstanceDataDir(instanceName: string): string {
  return join(
    homedir(),
    "Library",
    "Application Support",
    instanceName.replace(/ /g, "")
  );
}

export function getInstanceAppPath(instanceName: string): string {
  return join(homedir(), "Applications", `${instanceName}.app`);
}

function generateScriptContent(instanceName: string): string {
  const dataDir = getInstanceDataDir(instanceName);
  const appPath = getInstanceAppPath(instanceName);

  return `#!/usr/bin/env bash
# Generated by cursor-kit for instance: ${instanceName}
# This script opens the specified directory (or current directory) in the Cursor instance

set -euo pipefail

DIR="\${1:-.}"

# Resolve to absolute path if relative
if [[ "\$DIR" != /* ]]; then
  DIR="\$(cd "\$DIR" 2>/dev/null && pwd)"
fi

DATA_DIR="${dataDir}"
APP_PATH="${appPath}"

if [ ! -d "\$APP_PATH" ]; then
  echo "Error: Cursor instance not found at \$APP_PATH" >&2
  echo "The instance may have been removed. Run 'cursor-kit instance -l' to see available instances." >&2
  exit 1
fi

open -n "\$APP_PATH" --args --user-data-dir "\$DATA_DIR" "\$DIR"
`;
}

function generateShellFunction(
  aliasName: string,
  instanceName: string
): string {
  const dataDir = getInstanceDataDir(instanceName);
  const appPath = getInstanceAppPath(instanceName);

  return `
# cursor-kit alias: ${aliasName} -> ${instanceName}
${aliasName}() {
  local DIR="\${1:-.}"
  if [[ "\$DIR" != /* ]]; then
    DIR="\$(cd "\$DIR" 2>/dev/null && pwd)"
  fi
  local DATA_DIR="${dataDir}"
  local APP_PATH="${appPath}"
  if [ ! -d "\$APP_PATH" ]; then
    echo "Error: Cursor instance not found at \$APP_PATH" >&2
    return 1
  fi
  open -n "\$APP_PATH" --args --user-data-dir "\$DATA_DIR" "\$DIR"
}
# end cursor-kit alias: ${aliasName}
`;
}

export function detectShellConfigPath(): string {
  const home = homedir();
  const shell = process.env.SHELL ?? "/bin/zsh";

  if (shell.includes("zsh")) {
    return join(home, ".zshrc");
  }
  if (shell.includes("bash")) {
    const bashProfile = join(home, ".bash_profile");
    if (existsSync(bashProfile)) {
      return bashProfile;
    }
    return join(home, ".bashrc");
  }

  return join(home, ".zshrc");
}

export function getHomeBinDir(): string {
  return join(homedir(), "bin");
}

export function getUsrLocalBinDir(): string {
  return "/usr/local/bin";
}

function ensureBinDir(binDir: string): void {
  if (!existsSync(binDir)) {
    mkdirSync(binDir, { recursive: true });
  }
}

export function createExecutableScript(
  aliasName: string,
  instanceName: string,
  targetDir: string
): string {
  ensureBinDir(targetDir);

  const scriptPath = join(targetDir, aliasName);
  const scriptContent = generateScriptContent(instanceName);

  writeFileSync(scriptPath, scriptContent, "utf-8");
  chmodSync(scriptPath, 0o755);

  return scriptPath;
}

export function createShellAlias(
  aliasName: string,
  instanceName: string,
  shellConfigPath: string
): void {
  const functionContent = generateShellFunction(aliasName, instanceName);

  if (!existsSync(shellConfigPath)) {
    writeFileSync(shellConfigPath, "", "utf-8");
  }

  const existingContent = readFileSync(shellConfigPath, "utf-8");
  if (existingContent.includes(`# cursor-kit alias: ${aliasName}`)) {
    removeShellAlias(aliasName, shellConfigPath);
  }

  appendFileSync(shellConfigPath, functionContent, "utf-8");
}

export function removeShellAlias(
  aliasName: string,
  shellConfigPath: string
): boolean {
  if (!existsSync(shellConfigPath)) {
    return false;
  }

  const content = readFileSync(shellConfigPath, "utf-8");
  const startMarker = `# cursor-kit alias: ${aliasName}`;
  const endMarker = `# end cursor-kit alias: ${aliasName}`;

  const startIndex = content.indexOf(startMarker);
  if (startIndex === -1) {
    return false;
  }

  const endIndex = content.indexOf(endMarker);
  if (endIndex === -1) {
    return false;
  }

  const before = content.slice(0, startIndex);
  const after = content.slice(endIndex + endMarker.length);

  const newContent = (before + after).replace(/\n{3,}/g, "\n\n");
  writeFileSync(shellConfigPath, newContent, "utf-8");

  return true;
}

export function removeExecutableScript(scriptPath: string): boolean {
  if (!existsSync(scriptPath)) {
    return false;
  }

  try {
    unlinkSync(scriptPath);
    return true;
  } catch {
    return false;
  }
}

export interface CreateAliasOptions {
  aliasName: string;
  instanceName: string;
  storageLocation: AliasStorageLocation;
}

export interface CreateAliasResult {
  success: boolean;
  scriptPath?: string;
  shellConfigPath?: string;
  error?: string;
}

export function createAlias(options: CreateAliasOptions): CreateAliasResult {
  const { aliasName, instanceName, storageLocation } = options;

  try {
    let scriptPath: string | undefined;
    let shellConfigPath: string | undefined;

    switch (storageLocation) {
      case "shell-config": {
        shellConfigPath = detectShellConfigPath();
        createShellAlias(aliasName, instanceName, shellConfigPath);
        break;
      }
      case "usr-local-bin": {
        scriptPath = createExecutableScript(
          aliasName,
          instanceName,
          getUsrLocalBinDir()
        );
        break;
      }
      case "home-bin": {
        scriptPath = createExecutableScript(
          aliasName,
          instanceName,
          getHomeBinDir()
        );
        break;
      }
    }

    const config = loadAliasConfig();
    config.aliases[aliasName] = {
      instanceName,
      aliasName,
      storageLocation,
      createdAt: new Date().toISOString(),
      scriptPath,
    };
    saveAliasConfig(config);

    return { success: true, scriptPath, shellConfigPath };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

export function removeAlias(aliasName: string): boolean {
  const config = loadAliasConfig();
  const entry = config.aliases[aliasName];

  if (!entry) {
    return false;
  }

  let removed = false;

  switch (entry.storageLocation) {
    case "shell-config": {
      const shellConfigPath = detectShellConfigPath();
      removed = removeShellAlias(aliasName, shellConfigPath);
      break;
    }
    case "usr-local-bin": {
      const scriptPath = join(getUsrLocalBinDir(), aliasName);
      removed = removeExecutableScript(scriptPath);
      break;
    }
    case "home-bin": {
      const scriptPath = join(getHomeBinDir(), aliasName);
      removed = removeExecutableScript(scriptPath);
      break;
    }
  }

  delete config.aliases[aliasName];
  saveAliasConfig(config);

  return removed;
}

export function getAliasForInstance(instanceName: string): AliasEntry | null {
  const config = loadAliasConfig();

  for (const entry of Object.values(config.aliases)) {
    if (entry.instanceName === instanceName) {
      return entry;
    }
  }

  return null;
}

export function getAliasByName(aliasName: string): AliasEntry | null {
  const config = loadAliasConfig();
  return config.aliases[aliasName] ?? null;
}

export function listAliases(): AliasEntry[] {
  const config = loadAliasConfig();
  return Object.values(config.aliases);
}

export function aliasExists(aliasName: string): boolean {
  const config = loadAliasConfig();
  return aliasName in config.aliases;
}

export function generateAliasName(instanceName: string): string {
  return instanceName
    .toLowerCase()
    .replace(/^cursor\s*/i, "cursor-")
    .replace(/\s+/g, "-")
    .replace(/[^a-z0-9-]/g, "")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");
}

export function getStorageLocationLabel(
  location: AliasStorageLocation
): string {
  switch (location) {
    case "shell-config":
      return "Shell config (~/.zshrc or ~/.bashrc)";
    case "usr-local-bin":
      return "/usr/local/bin (system-wide)";
    case "home-bin":
      return "~/bin (user-local)";
  }
}

export function isHomeBinInPath(): boolean {
  const pathEnv = process.env.PATH ?? "";
  const homeBin = getHomeBinDir();
  return pathEnv
    .split(":")
    .some((p) => p === homeBin || p === "~/bin" || p === "$HOME/bin");
}

export function getPathSetupInstructions(): string {
  const shell = process.env.SHELL ?? "/bin/zsh";
  const configFile = shell.includes("zsh") ? "~/.zshrc" : "~/.bashrc";

  return `Add the following to your ${configFile}:

export PATH="$HOME/bin:$PATH"

Then restart your terminal or run: source ${configFile}`;
}
